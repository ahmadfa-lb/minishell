// int ft_execute_command(t_data *data)
// {
//     int status = 0;
//     int parser_length;
//     int nb_pipes;
//     int pipe_fds[2];
//     int in_fd = STDIN_FILENO;
//     t_cmd *current_cmd;
//     pid_t pid;

//     parser_length = ft_lstsize1(data->cmd_list);
//     nb_pipes = parser_length - 1;

//     current_cmd = data->cmd_list;

//     while (current_cmd)
//     {
//         // Validate the command before execution
//         if (!ft_verify_if_cmd_is_valid(data, current_cmd))
//         {
//             current_cmd = current_cmd->next;
//             continue;
//         }
//         // return (data->exit_status);

//         // Create a pipe if there are still more commands
//         if (nb_pipes > 0)
//         {
//             if (pipe(pipe_fds) == -1)
//             {
//                 perror("pipe");
//                 exit(EXIT_FAILURE);
//             }
//         }

//         // Fork the process
//         pid = fork();
//         if (pid == -1)
//         {
//             perror("fork");
//             exit(EXIT_FAILURE);
//         }
//         else if (pid == 0) // Child process
//         {
//             // Handle input redirection from the previous command's pipe
//             if (in_fd != STDIN_FILENO)
//             {
//                 dup2(in_fd, STDIN_FILENO);
//                 close(in_fd);
//             }

//             // Handle output redirection to the next command's pipe
//             if (nb_pipes > 0)
//             {
//                 dup2(pipe_fds[1], STDOUT_FILENO);
//                 close(pipe_fds[1]);
//                 close(pipe_fds[0]);
//             }

//             // Execute the command
//             char **arguments = build_arguments(current_cmd->tokens_list);
//             execve(current_cmd->command_path, arguments, data->env_array);
//             perror("execve");
//             free(arguments);
//             exit(EXIT_FAILURE);
//         }
//         else // Parent process
//         {
//             // Close pipe ends not needed by the parent
//             if (in_fd != STDIN_FILENO)
//                 close(in_fd);
//             if (nb_pipes > 0)
//             {
//                 close(pipe_fds[1]);
//                 in_fd = pipe_fds[0]; // Next command reads from this pipe
//             }

//             // Wait for the child process to finish
//             waitpid(pid, &status, 0);
//             data->exit_status = WEXITSTATUS(status);
//         }

//         current_cmd = current_cmd->next;
//         nb_pipes--;
//     }

//     return status;
// }

// int ft_execute_command(t_data *data)
// {
//     int status = 0;
//     int parser_length;
//     int nb_pipes;
//     int pipe_fds[2];
//     int in_fd = STDIN_FILENO;
//     t_cmd *current_cmd;
//     pid_t pid;

//     parser_length = ft_lstsize1(data->cmd_list);
//     nb_pipes = parser_length - 1;

//     current_cmd = data->cmd_list;

//     while (current_cmd)
//     {
//         // Validate the command before execution
//         if (!ft_verify_if_cmd_is_valid(data, current_cmd))
//         {
//             current_cmd = current_cmd->next;
//             continue;
//         }

//         // Handle redirections
//         t_list_tokens *redir = current_cmd->list_redirectors;
//         while (redir)
//         {
//             redirect(data, redir->type, redir->next);
//             redir = redir->next;
//         }

//         // Create a pipe if there are still more commands
//         if (nb_pipes > 0)
//         {
//             if (pipe(pipe_fds) == -1)
//             {
//                 perror("pipe");
//                 exit(EXIT_FAILURE);
//             }
//         }

//         // Fork the process
//         pid = fork();
//         if (pid == -1)
//         {
//             perror("fork");
//             exit(EXIT_FAILURE);
//         }
//         else if (pid == 0) // Child process
//         {
//             // Handle input redirection from the previous command's pipe
//             if (in_fd != STDIN_FILENO)
//             {
//                 dup2(in_fd, STDIN_FILENO);
//                 close(in_fd);
//             }

//             // Handle output redirection to the next command's pipe
//             if (nb_pipes > 0)
//             {
//                 dup2(pipe_fds[1], STDOUT_FILENO);
//                 close(pipe_fds[1]);
//                 close(pipe_fds[0]);
//             }

//             // Execute the command
//             char **arguments = build_arguments(current_cmd->tokens_list);
//             execve(current_cmd->command_path, arguments, data->env_array);
//             perror("execve");
//             free(arguments);
//             exit(EXIT_FAILURE);
//         }
//         else // Parent process
//         {
//             // Close pipe ends not needed by the parent
//             if (in_fd != STDIN_FILENO)
//                 close(in_fd);
//             if (nb_pipes > 0)
//             {
//                 close(pipe_fds[1]);
//                 in_fd = pipe_fds[0]; // Next command reads from this pipe
//             }

//             // Wait for the child process to finish
//             waitpid(pid, &status, 0);
//             data->exit_status = WEXITSTATUS(status);
//         }

//         current_cmd = current_cmd->next;
//         nb_pipes--;
//     }

//     return status;
// }