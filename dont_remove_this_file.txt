// int ft_execute_command(t_data *data,t_cmd *current_cmd)
// {
//     int status;
//     int in_fd;
//     pid_t *pids;
//     int i;
//     int j;
    
//     status = 0;
//     in_fd = STDIN_FILENO;
//     data->saved_stdout = dup(STDOUT_FILENO);
//     data->saved_stdin = dup(STDIN_FILENO);
//     pids = malloc(sizeof(pid_t) * (data->nb_pipes + 1));
//     i = 0;

//     while (current_cmd)
//     {
//         if (!ft_verify_if_cmd_is_valid(data, current_cmd))
//         {
//             current_cmd = current_cmd->next;
//             continue;
//         }

//         handle_redirections(data, current_cmd);
//         handle_piping(data->pipe_fds, data->nb_pipes);
//         pids[i] = handle_forking();

//         if (pids[i] == 0) // Child process
//         {
//             if (in_fd != STDIN_FILENO)
//             {
//                 dup2(in_fd, STDIN_FILENO);
//                 close(in_fd);
//             }
//             if (data->nb_pipes > 0)
//             {
//                 dup2(data->pipe_fds[1], STDOUT_FILENO);
//                 close(data->pipe_fds[1]);
//                 close(data->pipe_fds[0]);
//             }
//             execute_command(current_cmd, data);
//         }
//         else
//         {
//             // Parent process
//             if (in_fd != STDIN_FILENO)
//                 close(in_fd);
//             if (data->nb_pipes > 0)
//             {
//                 close(data->pipe_fds[1]);
//                 in_fd = data->pipe_fds[0];
//             }
//         }

//         dup2(data->saved_stdout, STDOUT_FILENO);
//         dup2(data->saved_stdin, STDIN_FILENO);
//         current_cmd = current_cmd->next;
//         data->nb_pipes--;
//         i++;
//     }

//     // Wait for all child processes to finish
//     j = 0;
//     while (j < i) // Use i instead of nb_pipes as it tracks the number of created processes
//     {
//         waitpid(pids[j], &status, 0);
//         data->exit_status = WEXITSTATUS(status);
//         j++;
//     }

//     free(pids);
//     close(data->saved_stdout);
//     close(data->saved_stdin);
//     return status;
// }


++__+___++_+__+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++__+___++_+__+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++__+___++_+__+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++__+___++_+__+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++__+___++_+__+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>  // For open()
#include <stdbool.h>
#include <readline/readline.h>

// Define token types
typedef enum { LESS_LESS } t_tokens_type;  // Define token types as needed
typedef enum { NO_QUOTE, SINGLE_QUOTE, DOUBLE_QUOTE } t_quote_type; // Add other quote types as needed

typedef struct s_token {
    t_tokens_type type;
    t_quote_type quote_type;
    char *value;
    bool space;
    struct s_token *next;
} t_list_tokens;

typedef struct s_cmd {
    t_list_tokens *tokens_list;
    t_list_tokens *list_redirectors;
    char *command_path;
    char *hd_file_name;  // For heredoc filename
    struct s_cmd *next;
    struct s_cmd *prev;
} t_cmd;

typedef struct s_env {
    char *key;
    char *value;
    int hidden;
    struct s_env *next;
} t_env;

typedef struct s_data {
    t_cmd *cmd_list;  // List of commands
    t_env *env_list;  // List of environment variables
    t_list_tokens *first_tokens_list; // Other fields as needed
    char **env_array;  // Array of environment variables
    int nb_pipes;      // Number of pipes
    int saved_stdout;  // Saved standard output
    int saved_stdin;   // Saved standard input
    int pipe_fds[2];   // Pipe file descriptors
    int exit_status;    // Exit status
    char *user_input;   // User input
} t_data;

// Function prototypes
char *generate_temp_filename(void);
char *handle_heredoc(t_data *data, t_list_tokens *redirector);
int send_heredoc(t_data *data);

// Generate a temporary filename
char *generate_temp_filename(void) {
    static int i = 0;
    char *filename = malloc(50);
    if (filename) {
        snprintf(filename, 50, "/tmp/heredoc_%d.txt", i++);
    }
    return filename;
}

// Handle heredoc input and write to a temporary file
char *handle_heredoc(t_data *data, t_list_tokens *redirector) {
    char *line = NULL;
    char *temp_filename = generate_temp_filename();
    int fd;

    if (!temp_filename) {
        return NULL;  // Return if generating the temp filename failed
    }

    fd = open(temp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open");
        free(temp_filename);
        return NULL;
    }

    // Loop until the delimiter is detected
    while (1) {
        line = readline("> ");
        if (!line) {
            perror("readline");
            break;  // Exit loop if readline fails
        }

        // Check if the input matches the heredoc delimiter
        if (strcmp(line, redirector->value) == 0) {
            free(line);
            break;  // Break the loop if the delimiter is matched
        }

        // Write the input line to the temporary file
        write(fd, line, strlen(line));
        write(fd, "\n", 1);  // Add the newline character
        free(line);  // Free the line after writing it to the file
    }

    close(fd);
    return temp_filename;  // Return the name of the temporary file
}

// Send heredoc for commands
int send_heredoc(t_data *data) {
    t_cmd *cmd = data->cmd_list;  // Start with the first command
    int result = EXIT_SUCCESS;

    while (cmd) {
        if (cmd->list_redirectors && cmd->list_redirectors->type == LESS_LESS) {
            // Generate the heredoc filename
            if (cmd->hd_file_name) {
                free(cmd->hd_file_name);  // Free the old filename if it exists
            }
            cmd->hd_file_name = handle_heredoc(data, cmd->list_redirectors);
            if (!cmd->hd_file_name) {
                result = EXIT_FAILURE;  // Handle failure to create heredoc
                break;
            }
        }
        cmd = cmd->next;  // Move to the next command
    }

    return result;  // Return the result of the heredoc processing
}

// Test main function
int main(void) {
    // Setup a minimal data structure
    t_data data;
    t_cmd cmd;
    t_list_tokens redirector;

    // Initialize the redirector for heredoc
    redirector.type = LESS_LESS;
    redirector.quote_type = NO_QUOTE;  // Change this to SINGLE_QUOTE or DOUBLE_QUOTE as needed
    redirector.value = "hola";  // The delimiter for heredoc
    redirector.next = NULL;  // No additional tokens

    // Link the redirector to the command
    cmd.list_redirectors = &redirector;  // Assign the redirector to the command
    cmd.hd_file_name = NULL;  // Initialize the heredoc filename to NULL
    cmd.next = NULL;  // No additional commands for this test

    // Link the command to the data structure
    data.cmd_list = &cmd;  // Assign the command to the data
    data.env_list = NULL;  // Initialize the env list as NULL

    // Call the send_heredoc function
    if (send_heredoc(&data) == EXIT_SUCCESS) {
        printf("Heredoc created: %s\n", cmd.hd_file_name);
    } else {
        printf("Failed to create heredoc.\n");
    }

    // Clean up (freeing allocated memory, etc.)
    free(cmd.hd_file_name);  // Free the heredoc filename if it was allocated

    return 0;
}
